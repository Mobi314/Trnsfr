import pandas as pd
import re

# Get the Alteryx input
df = Alteryx.read("#1")

# Define a function to check if a string represents a valid STOCK_REC_QTY
def is_valid_stock_rec_qty(s):
    # Validates strings like 4000.00000, .00000, -4000.00000, or -.00000
    return bool(re.match(r'^-?\d*\.?\d+$', s)) or bool(re.match(r'^-?\.\d+$', s))

def parse_combined_record(record):
    fields = {
        'SECURITY': '',
        'CUSIP': '',
        'SECURITY_DESC': '',
        'STOCK_REC_QTY': '',
        'CMS_SEG_QTY': '',
        'CAMS_SEG_QTY': '',
        'DTC_QTY': '',
        'NON_DTC_GCL': '',
        'OPT_SEG_QTY': '',
        'TOTAL': ''
    }
    
    # Split the record by spaces
    parts = record.split()
    idx = 0
    
    # Parse forward to get SECURITY and CUSIP
    while idx < len(parts):
        part = parts[idx]
        # Check if the part represents SECURITY
        if re.match(r'^\w+$', part):
            fields['SECURITY'] = part
            idx += 1
            break
        idx += 1
    
    while idx < len(parts):
        part = parts[idx]
        # Check if the part represents CUSIP
        if re.match(r'^\w+$', part):
            fields['CUSIP'] = part
            idx += 1
            break
        idx += 1
    
    # Parse forward to get STOCK_REC_QTY
    potential_stock_qty = []
    while idx < len(parts):
        part = parts[idx]
        if re.match(r'^\d', part) or re.match(r'^\.', part):
            potential_stock_qty.append(part)
            # Check if the potential STOCK_REC_QTY meets the criteria
            if is_valid_stock_rec_qty(' '.join(potential_stock_qty)):
                fields['STOCK_REC_QTY'] = ' '.join(potential_stock_qty).strip()
                break
        else:
            if potential_stock_qty:
                potential_stock_qty = []
        idx += 1
    
    # Parse backward to get SECURITY_DESC
    desc_end_idx = idx - 1
    desc_start_idx = 1  # Start after SECURITY and CUSIP
    desc = parts[desc_start_idx:desc_end_idx]
    fields['SECURITY_DESC'] = ' '.join(desc).strip()
    
    # Move index past any large series of spaces
    while idx < len(parts) and parts[idx] == '':
        idx += 1
    
    # Parse forward to get the remaining fields
    if idx < len(parts):
        fields['CMS_SEG_QTY'] = parts[idx]
        idx += 1
    if idx < len(parts):
        fields['CAMS_SEG_QTY'] = parts[idx]
        idx += 1
    if idx < len(parts):
        fields['DTC_QTY'] = parts[idx]
        idx += 1
    if idx < len(parts):
        fields['NON_DTC_GCL'] = parts[idx]
        idx += 1
    if idx < len(parts):
        fields['OPT_SEG_QTY'] = parts[idx]
        idx += 1
    if idx < len(parts):
        fields['TOTAL'] = parts[idx]
    
    return fields
This modification should provide a more accurate parsing by considering both forward and reverse directions.


No, you mistake me, I want to parse forward only for SECURITY and CUSIP, the order of the columns as laid out initially in the code is the exact order of the various data in the string of characters in the field in total. We need to parse in reverse for the last 7 columns, parse forward for the first two, being security and cusip, and everything in between is SECURITY_DESC
ChatGPT
Got it, let's adjust the parsing logic accordingly to parse forward for SECURITY and CUSIP and parse in reverse for the remaining fields. Here's the updated code:

python
Copy code
def parse_combined_record(record):
    fields = {
        'SECURITY': '',
        'CUSIP': '',
        'SECURITY_DESC': '',
        'STOCK_REC_QTY': '',
        'CMS_SEG_QTY': '',
        'CAMS_SEG_QTY': '',
        'DTC_QTY': '',
        'NON_DTC_GCL': '',
        'OPT_SEG_QTY': '',
        'TOTAL': ''
    }
    
    # Split the record by spaces
    parts = record.split()
    idx = 0
    
    # Parse forward to get SECURITY
    while idx < len(parts):
        part = parts[idx]
        # Check if the part represents SECURITY
        if re.match(r'^\w+$', part):
            fields['SECURITY'] = part
            idx += 1
            break
        idx += 1
    
    # Parse forward to get CUSIP
    while idx < len(parts):
        part = parts[idx]
        # Check if the part represents CUSIP
        if re.match(r'^\w+$', part):
            fields['CUSIP'] = part
            idx += 1
            break
        idx += 1
    
    # Parse in reverse to get the remaining fields
    desc_end_idx = len(parts) - 7
    desc_start_idx = idx  # Start after SECURITY and CUSIP
    desc = parts[desc_start_idx:desc_end_idx]
    fields['SECURITY_DESC'] = ' '.join(desc).strip()
    
    # Parse forward to get STOCK_REC_QTY
    potential_stock_qty = []
    for i in range(len(parts) - 1, desc_end_idx - 1, -1):
        part = parts[i]
        if re.match(r'^\d', part) or re.match(r'^\.', part):
            potential_stock_qty.append(part)
            # Check if the potential STOCK_REC_QTY meets the criteria
            if is_valid_stock_rec_qty(' '.join(potential_stock_qty)):
                fields['STOCK_REC_QTY'] = ' '.join(potential_stock_qty).strip()
                break
    
    # Move index past any large series of spaces
    while idx < len(parts) and parts[idx] == '':
        idx += 1
    
    # CMS SEG QTY
    if idx < len(parts):
        fields['CMS_SEG_QTY'] = parts[idx]
        idx += 1
    
    # CAMS SEG QTY
    if idx < len(parts):
        fields['CAMS_SEG_QTY'] = parts[idx]
        idx += 1
    
    # DTC QTY
    if idx < len(parts):
        fields['DTC_QTY'] = parts[idx]
        idx += 1
    
    # NON DTC GCL
    if idx < len(parts):
        fields['NON_DTC_GCL'] = parts[idx]
        idx += 1
    
    # OPT SEG QTY
    if idx < len(parts):
        fields['OPT_SEG_QTY'] = parts[idx]
        idx += 1
    
    # TOTAL
    if idx < len(parts):
        fields['TOTAL'] = parts[idx]
    
    return fields

# Apply the function to each record
parsed_data = df['CombinedRecord'].apply(parse_combined_record)
parsed_df = pd.DataFrame(parsed_data.tolist())

# Concatenate with the original dataframe
result_df = pd.concat([df, parsed_df], axis=1)

# Output the result
Alteryx.write(result_df, 1)
